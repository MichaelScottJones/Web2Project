<h1 class="header">Lesson 5: Lazy Operators</h1>
<div class="readable">
    <p>The quick fix to this problem is to make the plus lazy instead of greedy. Lazy quantifiers are sometimes also called "ungreedy" or "reluctant". You can do that by putting a question mark after the plus in the regex. You can do the same with the star, the curly braces and the question mark itself. So our example becomes <code><.+?></code>. Let's have another look inside the regex engine.</p>

    <p>Again, <code><</code> matches the first <code><</code> in the string. The next token is the dot, this time repeated by a lazy plus. This tells the regex engine to repeat the dot as few times as possible. The minimum is one. So the engine matches the dot with E. The requirement has been met, and the engine continues with <code>></code> and <code>M</code>. This fails. Again, the engine will backtrack. But this time, the backtracking will force the lazy plus to expand rather than reduce its reach. So the match of <code>.+</code> is expanded to <code>EM</code>, and the engine tries again to continue with <code>></code>. Now, <code>></code> is matched successfully. The last token in the regex has been matched. The engine reports that <EM> has been successfully matched. That's more like it.</p>

    <p>In this case, there is a better option than making the plus lazy. We can use a greedy plus and a negated character class: <code><[^>]+></code>. The reason why this is better is because of the backtracking. When using the lazy plus, the engine has to backtrack for each character in the HTML tag that it is trying to match. When using the negated character class, no backtracking occurs at all when the string contains valid HTML code. Backtracking slows down the regex engine. You will not notice the difference when doing a single search in a text editor. But you will save plenty of CPU cycles when using such a regex repeatedly in a tight loop in a script that you are writing, or perhaps in a custom syntax coloring scheme for EditPad Pro.</p>

    <p>Only regex-directed engines backtrack. Text-directed engines don't and thus do not get the speed penalty. But they also do not support lazy quantifiers.</p>
</div>